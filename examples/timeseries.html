<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cambridge Spatio-Temporal Data Visualization</title>
    <link href="https://unpkg.com/maplibre-gl@^4/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@^4/dist/maplibre-gl.js"></script>
    <script type="module">
        import { ScreenGridLayerGL, GlyphUtilities, Legend } from '../src/index.js';

        // Global state for hovered year reference
        let hoveredYear = null;
        let gridLayer = null;
        let legend = null;

        const map = new maplibregl.Map({
            container: 'map',
            // style: 'https://demotiles.maplibre.org/style.json',
            style: {
                    version: 8,
                    sources: {
                        'dark': {
                            type: 'raster',
                            tiles: ['https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'],
                            tileSize: 256,
                            attribution: '© OpenStreetMap contributors © CARTO'
                        }
                    },
                    layers: [
                        { id: 'dark', type: 'raster', source: 'dark', paint: { 'raster-opacity': 1.0 } }
                    ]
                },
            // center shows cambridge, uk
            center: [0.1278, 52.2053], 
            zoom: 12
        });

        /**
         * Custom glyph function for time series visualization
         * Groups data by year and aggregates ashp_carbonsaved values
         * Also draws reference line for hovered year if applicable
         */
        function drawTimeSeriesGlyph(ctx, x, y, normVal, cellInfo) {
            const { cellData, cellSize } = cellInfo;
            
            if (!cellData || cellData.length === 0) return;

            // Group data by year and aggregate ashp_carbonsaved
            const yearData = {};
            
            cellData.forEach(item => {
                const year = item.data.year;
                const carbonSaved = item.data.ashp_carbonsaved;
                
                // Skip null/undefined values
                if (carbonSaved == null || isNaN(carbonSaved)) return;
                
                if (!yearData[year]) {
                    yearData[year] = {
                        year: year,
                        total: 0,
                        count: 0
                    };
                }
                
                yearData[year].total += carbonSaved;
                yearData[year].count += 1;
            });

            // Convert to array and calculate average (or use sum)
            const timeSeriesData = Object.values(yearData).map(d => ({
                year: d.year,
                value: d.total // Use sum, or change to d.total / d.count for average
            }));

            if (timeSeriesData.length === 0) return;

            // Get year range for this cell
            const years = timeSeriesData.map(d => d.year);
            const minYear = Math.min(...years);
            const maxYear = Math.max(...years);
            const yearRange = maxYear - minYear || 1;

            // Draw time series chart
            const padding = 0.15;
            GlyphUtilities.drawTimeSeriesGlyph(
                ctx,
                x,
                y,
                timeSeriesData,
                cellSize,
                {
                    lineColor: '#2ecc71',
                    pointColor: '#27ae60',
                    lineWidth: 2,
                    pointRadius: 2.5,
                    showPoints: true,
                    showArea: true,
                    areaColor: 'rgba(46, 204, 113, 0.15)',
                    padding: padding
                }
            );

            // Draw reference line for hovered year if it exists in this cell's data
            if (hoveredYear !== null && hoveredYear >= minYear && hoveredYear <= maxYear) {
                const chartWidth = cellSize * (1 - 2 * padding);
                const chartHeight = cellSize * (1 - 2 * padding);
                const chartX = x - chartWidth / 2;
                const chartY = y - chartHeight / 2;
                
                // Calculate x position for the hovered year
                const yearX = chartX + ((hoveredYear - minYear) / yearRange) * chartWidth;
                
                // Draw vertical reference line
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([3, 3]); // Dashed line
                ctx.beginPath();
                ctx.moveTo(yearX, chartY);
                ctx.lineTo(yearX, chartY + chartHeight);
                ctx.stroke();
                ctx.setLineDash([]); // Reset dash
                
                // Draw a small circle at the intersection with the line (if data exists for this year)
                const yearValue = timeSeriesData.find(d => d.year === hoveredYear);
                if (yearValue) {
                    const values = timeSeriesData.map(d => d.value);
                    const minValue = Math.min(...values);
                    const maxValue = Math.max(...values);
                    const valueRange = maxValue - minValue || 1;
                    
                    const valueY = chartY + chartHeight - ((yearValue.value - minValue) / valueRange) * chartHeight;
                    
                    // Draw circle marker
                    ctx.fillStyle = 'rgba(150, 150, 150, 0.9)';
                    ctx.beginPath();
                    ctx.arc(yearX, valueY, 3.5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw white outline for better visibility
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Draw year label at the bottom of the chart
                ctx.fillStyle = 'rgba(150, 150, 150, 0.9)';
                ctx.font = 'bold 9px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(hoveredYear.toString(), yearX, chartY + chartHeight + 2);
            }
        }

        map.on('load', async () => {
            // Load cambridge data
            const data = await fetch('./data/cambridge.json').then(r => r.json());
            
            console.log(`Loaded ${data.length} data points`);
            console.log('Sample data:', data[0]);

            // Filter to only include entries with valid coordinates and ashp_carbonsaved
            const validData = data.filter(d => 
                d.lat != null && 
                d.lon != null && 
                d.year != null &&
                d.ashp_carbonsaved != null
            );

            console.log(`Using ${validData.length} valid data points`);

            gridLayer = new ScreenGridLayerGL({
                id: 'cambridge-timeseries',
                data: validData,
                getPosition: (d) => [d.lon, d.lat],
                getWeight: (d) => d.ashp_carbonsaved || 0,
                cellSizePixels: 80,
                colorScale: (v) => [255 * v, 200 * (1 - v), 50, 180],
                enableGlyphs: true,
                glyphSize: 0.9,
                onDrawCell: drawTimeSeriesGlyph,
                onAggregate: (grid) => {
                    console.log('Grid aggregated:', {
                        cols: grid.cols,
                        rows: grid.rows,
                        cellsWithData: grid.grid.filter(v => v > 0).length,
                        maxValue: Math.max(...grid.grid)
                    });
                },
                onHover: ({ cell, event }) => {
                    // Clear reference line if hovering over cell without data
                    if (!cell || !cell.cellData || cell.cellData.length === 0) {
                        if (hoveredYear !== null) {
                            hoveredYear = null;
                            gridLayer.render();
                        }
                        return;
                    }

                    // Group by year for display
                    const yearGroups = {};
                    cell.cellData.forEach(item => {
                        const year = item.data.year;
                        if (!yearGroups[year]) {
                            yearGroups[year] = {
                                total: 0,
                                count: 0
                            };
                        }
                        if (item.data.ashp_carbonsaved != null) {
                            yearGroups[year].total += item.data.ashp_carbonsaved;
                            yearGroups[year].count += 1;
                        }
                    });
                    
                    // Calculate which year the mouse is over based on x position within cell
                    const cellSize = gridLayer.config.cellSizePixels;
                    const mouseX = event.point.x;
                    
                    // Calculate relative position within the cell (0 to 1)
                    // cell.x is the left edge of the cell in canvas coordinates
                    const relativeX = (mouseX - cell.x) / cellSize;
                    
                    // Get year range for this cell
                    const years = Object.keys(yearGroups).map(y => parseInt(y)).sort((a, b) => a - b);
                    if (years.length > 0) {
                        const minYear = Math.min(...years);
                        const maxYear = Math.max(...years);
                        const yearRange = maxYear - minYear || 1;
                        
                        // Calculate year based on mouse x position within the chart area
                        // Account for padding: chart starts at padding, ends at (1 - padding)
                        const padding = 0.15;
                        const chartStart = padding;
                        const chartEnd = 1 - padding;
                        const chartWidth = chartEnd - chartStart;
                        
                        // Normalize relativeX to chart area
                        const normalizedX = (relativeX - chartStart) / chartWidth;
                        const clampedX = Math.max(0, Math.min(1, normalizedX));
                        
                        const calculatedYear = Math.round(minYear + clampedX * yearRange);
                        
                        // Only update if year is valid and in range
                        if (calculatedYear >= minYear && calculatedYear <= maxYear) {
                            hoveredYear = calculatedYear;
                            // Trigger re-render to show reference lines
                            gridLayer.render();
                        }
                    } else {
                        // No valid years found, clear reference line
                        if (hoveredYear !== null) {
                            hoveredYear = null;
                            gridLayer.render();
                        }
                    }
                    
                    const yearSummary = Object.keys(yearGroups)
                        .sort()
                        .map(year => `${year}: ${yearGroups[year].total.toFixed(1)} kg CO₂`)
                        .join('\n');
                    
                    // console.log(`Cell at [${cell.col}, ${cell.row}]:\n${yearSummary}`);
                    if (hoveredYear !== null) {
                        console.log(`Hovered year: ${hoveredYear}`);
                    }
                },
                onClick: ({ cell }) => {
                    if (cell.cellData && cell.cellData.length > 0) {
                        const yearGroups = {};
                        cell.cellData.forEach(item => {
                            const year = item.data.year;
                            if (!yearGroups[year]) {
                                yearGroups[year] = { total: 0, count: 0 };
                            }
                            if (item.data.ashp_carbonsaved != null) {
                                yearGroups[year].total += item.data.ashp_carbonsaved;
                                yearGroups[year].count += 1;
                            }
                        });
                        
                        const yearSummary = Object.keys(yearGroups)
                            .sort()
                            .map(year => `${year}: ${yearGroups[year].total.toFixed(1)} kg CO₂ (${yearGroups[year].count} points)`)
                            .join('\n');
                        
                        alert(`Cell Details:\n\n${yearSummary}\n\nTotal data points: ${cell.cellData.length}`);
                    }
                }
            });

            map.addLayer(gridLayer);

            // Create temporal legend
            // legend = new Legend({
            //     layer: gridLayer,
            //     type: 'temporal',
            //     position: 'bottom-left',
            //     title: 'Carbon Saved Over Time',
            //     timeExtractor: (d) => d.year,
            //     valueExtractor: (d) => d.ashp_carbonsaved,
            //     renderOptions: {
            //         timeFormat: (t) => t.toString(),
            //         showRange: true,
            //         showSamplePoints: true
            //     }
            // });

            // Clear hovered year when mouse leaves the map
            map.on('mouseout', () => {
                hoveredYear = null;
                gridLayer.render();
            });
        });
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="map"></div>
</body>
</html>

